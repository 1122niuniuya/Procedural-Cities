diff --git a/Content/FirstPersonCPP/Maps/standardmap.umap b/Content/FirstPersonCPP/Maps/standardmap.umap
index 163336c..1770c14 100644
Binary files a/Content/FirstPersonCPP/Maps/standardmap.umap and b/Content/FirstPersonCPP/Maps/standardmap.umap differ
diff --git a/Content/FirstPersonCPP/Maps/standardmap_BuiltData.uasset b/Content/FirstPersonCPP/Maps/standardmap_BuiltData.uasset
index a65439d..8d8c08b 100644
Binary files a/Content/FirstPersonCPP/Maps/standardmap_BuiltData.uasset and b/Content/FirstPersonCPP/Maps/standardmap_BuiltData.uasset differ
diff --git a/Content/ProcMeshActorBp.uasset b/Content/ProcMeshActorBp.uasset
index 40a5798..820bfa4 100644
Binary files a/Content/ProcMeshActorBp.uasset and b/Content/ProcMeshActorBp.uasset differ
diff --git a/Content/textActor.uasset b/Content/textActor.uasset
index 5e31994..aeaad59 100644
Binary files a/Content/textActor.uasset and b/Content/textActor.uasset differ
diff --git a/Source/City/BaseLibrary.cpp b/Source/City/BaseLibrary.cpp
index 4dbccdf..6c88a36 100644
--- a/Source/City/BaseLibrary.cpp
+++ b/Source/City/BaseLibrary.cpp
@@ -11,42 +11,55 @@ BaseLibrary::~BaseLibrary()
 {
 }
 
-void getMinMax(float &min, float &max, FVector tangent, FVector v1, FVector v2, FVector v3, FVector v4) {
-	float res = FVector::DotProduct(tangent, v1);
-	min = res;
-	max = res;
-	res = FVector::DotProduct(tangent, v2);
-	min = std::min(min, res);
-	max = std::max(max, res);
-	res = FVector::DotProduct(tangent, v3);
-	min = std::min(min, res);
-	max = std::max(max, res);
-	res = FVector::DotProduct(tangent, v4);
-	min = std::min(min, res);
-	max = std::max(max, res);
-}
-
-FVector intersection(FPolygon &p1, TArray<FPolygon> &p2) {
-	for (FPolygon &f : p2) {
-		FVector res = intersection(p1, f);
-		if (res.X != 0.0f) {
-			return res;
-		}
+void getMinMax(float &min, float &max, FVector tangent, TArray<FVector> points) {
+	min = FVector::DotProduct(tangent, points[0]);
+	max = FVector::DotProduct(tangent, points[0]);
+
+	for (int i = 1; i < points.Num(); i++) {
+		float res = FVector::DotProduct(tangent, points[i]);
+		min = std::min(min, res);
+		max = std::max(max, res);
 	}
-	return FVector(0.0f, 0.0f, 0.0f);
 }
 
-FVector intersection(FPolygon &p1, FPolygon &p2) {
-	for (int i = 1; i < p1.points.Num(); i++) {
-		for (int j = 1; j < p2.points.Num(); j++) {
-			FVector res = intersection(p1.points[i - 1], p1.points[i], p2.points[j - 1], p2.points[j]);
-			if (res.X != 0.0f) {
-				return res;
-			}
-		}
-	}
-	return FVector(0.0f, 0.0f, 0.0f);
-}
+
+
+//void getMinMax(float &min, float &max, FVector tangent, FVector v1, FVector v2, FVector v3, FVector v4) {
+//	float res = FVector::DotProduct(tangent, v1);
+//	min = res;
+//	max = res;
+//	res = FVector::DotProduct(tangent, v2);
+//	min = std::min(min, res);
+//	max = std::max(max, res);
+//	res = FVector::DotProduct(tangent, v3);
+//	min = std::min(min, res);
+//	max = std::max(max, res);
+//	res = FVector::DotProduct(tangent, v4);
+//	min = std::min(min, res);
+//	max = std::max(max, res);
+//}
+
+//FVector intersection(FPolygon &p1, TArray<FPolygon> &p2) {
+//	for (FPolygon &f : p2) {
+//		FVector res = intersection(p1, f);
+//		if (res.X != 0.0f) {
+//			return res;
+//		}
+//	}
+//	return FVector(0.0f, 0.0f, 0.0f);
+//}
+
+//FVector intersection(FPolygon &p1, FPolygon &p2) {
+//	for (int i = 1; i < p1.points.Num(); i++) {
+//		for (int j = 1; j < p2.points.Num(); j++) {
+//			FVector res = intersection(p1.points[i - 1], p1.points[i], p2.points[j - 1], p2.points[j]);
+//			if (res.X != 0.0f) {
+//				return res;
+//			}
+//		}
+//	}
+//	return FVector(0.0f, 0.0f, 0.0f);
+//}
 
 FVector intersection(FVector p1, FVector p2, FVector p3, FVector p4) {
 	float p0_x = p1.X;
@@ -86,17 +99,53 @@ FVector intersection(FVector p1, FVector p2, FPolygon p) {
 }
 
 
+
+bool testAxis(FVector axis, FPolygon &p1, FPolygon &p2, float leniency) {
+	float min1 = 0;
+	float max1 = 0;
+	float min2 = 0;
+	float max2 = 0;
+
+	getMinMax(min1, max1, axis, p1.points);
+	getMinMax(min2, max2, axis, p2.points);
+	if (std::max(min1, min2) >= std::min(max1, max2) - leniency) {
+		return false;
+	}
+	return true;
+}
+
+bool testCollision(FPolygon &p1, FPolygon &p2, float leniency) {
+	for (int i = 1; i < p1.points.Num(); i++) {
+		if (!testAxis(FRotator(0, 270, 0).RotateVector(p1.points[i] - p1.points[i-1]), p1, p2, leniency)) {
+			return false;
+		}
+	}
+	for (int i = 1; i < p2.points.Num(); i++) {
+		if (!testAxis(FRotator(0, 270, 0).RotateVector(p2.points[i] - p2.points[i-1]), p1, p2, leniency)) {
+			return false;
+		}
+	}
+	return true;
+}
+
+bool testCollision(FPolygon &in, TArray<FPolygon> &others, float leniency) {
+	for (FPolygon &other : others) {
+		if (testCollision(other, in, leniency)) {
+			return true;
+		}
+	}
+	return false;
+}
+
 // returns true if colliding
 bool testCollision(TArray<FVector> tangents, TArray<FVector> vertices1, TArray<FVector> vertices2, float collisionLeniency) {
-	// assume rectangles
 	float min1;
 	float max1;
 	float min2;
 	float max2;
-
 	for (FVector t : tangents) {
-		getMinMax(min1, max1, t, vertices1[0], vertices1[1], vertices1[2], vertices1[3]);
-		getMinMax(min2, max2, t, vertices2[0], vertices2[1], vertices2[2], vertices2[3]);
+		getMinMax(min1, max1, t, vertices1);
+		getMinMax(min2, max2, t, vertices2);
 		if (std::max(min1, min2) >= (std::min(max1, max2) - collisionLeniency)) {
 			return false;
 		}
diff --git a/Source/City/BaseLibrary.h b/Source/City/BaseLibrary.h
index 3b33dba..3be0250 100644
--- a/Source/City/BaseLibrary.h
+++ b/Source/City/BaseLibrary.h
@@ -41,7 +41,6 @@ enum class PolygonType : uint8
 };
 
 
-
 FVector intersection(FVector p1, FVector p2, FVector p3, FVector p4);
 
 struct SplitStruct {
@@ -687,17 +686,17 @@ struct FRoomPolygon : public FPolygon
 						if (newP == nullptr) {
 							break;
 						}
-						//if (target->nonDuplicatingEntrances.Num() > 0) {
-						//	FRoomPolygon *temp = target;
-						//	target = newP;
-						//	newP = target;
-						//}
-						//if (target->nonDuplicatingEntrances.Num() > 0) {
-						//	target->type = SubRoomType::hallway;
-						//}
-						//if (newP->nonDuplicatingEntrances.Num() > 0) {
-						//	newP->type = SubRoomType::hallway;
-						//}
+						if (target->nonDuplicatingEntrances.Num() > 0) {
+							FRoomPolygon *temp = target;
+							target = newP;
+							newP = target;
+						}
+						if (target->nonDuplicatingEntrances.Num() > 0) {
+							target->type = SubRoomType::hallway;
+						}
+						if (newP->nonDuplicatingEntrances.Num() > 0) {
+							newP->type = SubRoomType::hallway;
+						}
 						remaining.EmplaceAt(0, newP);
 						scale = r.minArea / target->getArea();
 
@@ -713,13 +712,13 @@ struct FRoomPolygon : public FPolygon
 						if (newP == nullptr) {
 							continue;
 						}
-						//if (newP->nonDuplicatingEntrances.Num() > 0) {
-						//	newP->type = SubRoomType::hallway;
-						//	FRoomPolygon *temp = target;
-						//	target = newP;
-						//	newP = target;
+						if (newP->nonDuplicatingEntrances.Num() > 0) {
+							newP->type = SubRoomType::hallway;
+							FRoomPolygon *temp = target;
+							target = newP;
+							newP = target;
 
-						//}
+						}
 						newP->type = r.type;
 						toReturn.Add(newP);
 						remaining.EmplaceAt(0, target);
@@ -736,20 +735,29 @@ struct FRoomPolygon : public FPolygon
 
 	}
 
+	int getTotalConnections() {
+		int totPassive = 0;
+		for (auto &list : passiveConnections) {
+			totPassive += list.Value.Num();
+		}
+		return activeConnections.Num() + totPassive;
+	}
+
+
 	// post placement part of algorithm
-	void postFit(TArray<FRoomPolygon> &rooms, TArray<RoomSpecification> neededRooms){
+	void postFit(TArray<FRoomPolygon*> &rooms, TArray<RoomSpecification> neededRooms){
 
-		TSet<RoomSpecification> foundRooms;
-		for (FRoomPolygon &p : rooms) {
-			if (!splitableType(p.type) && p.entrances.Num() + p.toIgnore.Num() > 1) {
-				p.type = SubRoomType::corridor;
+		TSet<SubRoomType> foundRooms;
+		for (FRoomPolygon *p : rooms) {
+			if (!splitableType(p->type) && p->getTotalConnections() > 1) {
+				p->type = SubRoomType::corridor;
 			}
 			else {
-				foundRooms.Add(p.type);
+				foundRooms.Add(p->type);
 			}
 		}
 		for (RoomSpecification r : neededRooms) {
-
+			
 		}
 	}
 
@@ -765,7 +773,7 @@ struct FRoomPolygon : public FPolygon
 		rooms.Append(fitSpecificationOnRooms(blueprint.needed, remaining, false));
 		rooms.Append(fitSpecificationOnRooms(blueprint.optional, remaining, true));
 
-		postFit(rooms);
+		//postFit(rooms, blueprint.needed);
 		TArray<FRoomPolygon> toReturn;
 		for (FRoomPolygon *p : remaining) {
 			//for (int i = 0; i < p.points.Num(); i++) {
@@ -1091,11 +1099,15 @@ Calculate whether two lines intersect and where
 */
 
 
-void getMinMax(float &min, float &max, FVector tangent, FVector v1, FVector v2, FVector v3, FVector v4);
-FVector intersection(FPolygon &p1, TArray<FPolygon> &p2);
-FVector intersection(FPolygon &p1, FPolygon &p2);
+void getMinMax(float &min, float &max, FVector tangent, TArray<FVector> points);
+
+//void getMinMax(float &min, float &max, FVector tangent, FVector v1, FVector v2, FVector v3, FVector v4);
+//FVector intersection(FPolygon &p1, TArray<FPolygon> &p2);
+//FVector intersection(FPolygon &p1, FPolygon &p2);
 FVector intersection(FVector p1, FVector p2, FVector p3, FVector p4);
 FVector intersection(FVector p1, FVector p2, FPolygon p);
+bool testCollision(FPolygon &, TArray<FPolygon> &, float leniency);
+bool testCollision(FPolygon &, FPolygon &, float leniency);
 bool testCollision(TArray<FVector> tangents, TArray<FVector> vertices1, TArray<FVector> vertices2, float collisionLeniency);
 float randFloat();
 FVector NearestPointOnLine(FVector linePnt, FVector lineDir, FVector pnt);
diff --git a/Source/City/HouseBuilder.cpp b/Source/City/HouseBuilder.cpp
index 159eac2..8ec498b 100644
--- a/Source/City/HouseBuilder.cpp
+++ b/Source/City/HouseBuilder.cpp
@@ -474,7 +474,7 @@ FRoomInfo AHouseBuilder::getHouseInfo(FHousePolygon f, int floors, float floorHe
 
 	}
 
-	//toReturn.pols.Append(otherSides);
+	toReturn.pols.Append(otherSides);
 	return toReturn;
 
 
diff --git a/Source/City/PlotBuilder.cpp b/Source/City/PlotBuilder.cpp
index 6a88a87..3677562 100644
--- a/Source/City/PlotBuilder.cpp
+++ b/Source/City/PlotBuilder.cpp
@@ -19,15 +19,15 @@ void APlotBuilder::BeginPlay()
 	
 }
 
-bool testCollision(TArray<FPolygon> &polygons, FPolygon &pol) {
-
-	for (FPolygon p2 : polygons) {
-		FVector res = intersection(pol, p2);
-		if (res.X != 0.0f)
-			return true;
-	}
-	return false;
-}
+//bool testCollision(TArray<FPolygon> &polygons, FPolygon &pol) {
+//
+//	for (FPolygon p2 : polygons) {
+//		FVector res = intersection(pol, p2);
+//		if (res.X != 0.0f)
+//			return true;
+//	}
+//	return false;
+//}
 
 TArray<FHousePolygon> APlotBuilder::generateHousePolygons(FPlotPolygon p, TArray<FPolygon> others, int maxFloors, int minFloors) {
 	TArray<FHousePolygon> housePolygons;
@@ -112,7 +112,7 @@ TArray<FHousePolygon> APlotBuilder::generateHousePolygons(FPlotPolygon p, TArray
 			//fh.windows.Add(2);
 			//fh.windows.Add(4);
 
-			if (!testCollision(others, pol)) {
+			if (!testCollision(pol, others, 500)) {
 				fh.points = pol.points;
 				fh.population = 1.0;
 				fh.height = randFloat() * (maxFloors - minFloors) + minFloors;
diff --git a/Source/City/RoomBuilder.cpp b/Source/City/RoomBuilder.cpp
index 1833cc3..89e2a5e 100644
--- a/Source/City/RoomBuilder.cpp
+++ b/Source/City/RoomBuilder.cpp
@@ -456,7 +456,7 @@ static TArray<FMeshInfo> getLivingRoom(FRoomPolygon &r2) {
 static TArray<FMeshInfo> getBathRoom(FRoomPolygon &r2) {
 	TArray<FMeshInfo> meshes;
 	
-	//r2.windows.Empty();
+	r2.windows.Empty();
 	//r2.entrances.Empty();
 	//r2.toIgnore.Empty();
 	TArray<FPolygon> placed;
@@ -495,8 +495,8 @@ bool attemptPlaceShelf(FRoomPolygon &r2, TArray<FPolygon> &placed, TArray<FMeshI
 		FVector pos = origin + dir * 10;
 		FRotator rot = dir.Rotation();
 		FPolygon shelfP = MeshPolygonReference::getShelfPolygon(pos, rot);
-		FVector res = intersection(shelfP, placed);
-		if (res.X == 0.0f) {
+		
+		if (!testCollision(shelfP, placed, 0)) {
 			placed.Add(shelfP);
 			FMeshInfo shelf{ "shelf", FTransform(rot , pos, FVector(1.0f, 1.0f, 1.0f))};
 			meshes.Add(shelf);
